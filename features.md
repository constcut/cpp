- [С++](#с)
  - [Операции](#операции)
  - [Функции](#функции)
    - [Операторы](#операторы)
    - [Lambda](#lambda)
    - [Функторы](#функторы)
    - [Пользовательские литералы](#пользовательские-литералы)
  - [Типы данных](#типы-данных)
    - [Статическая типизация](#статическая-типизация)
    - [Динамическая типезация](#динамическая-типезация)
      - [RTTI](#rtti)
  - [Указатели и ссылки](#указатели-и-ссылки)
    - [Модель памяти и время жизни](#модель-памяти-и-время-жизни)
    - [Ссылки](#ссылки)
    - [Сырые указатели](#сырые-указатели)
    - [Умные указатели](#умные-указатели)
  - [Структуры и классы: ООП](#структуры-и-классы-ооп)
    - [Конструкторы и деструткоры](#конструкторы-и-деструткоры)
    - [Статический полиморфизм](#статический-полиморфизм)
      - [Перегрузка методов](#перегрузка-методов)
    - [Динамический полиморфизм](#динамический-полиморфизм)
      - [Виртуальные методы](#виртуальные-методы)
      - [Таблица виртуальных методов](#таблица-виртуальных-методов)
    - [Правило 0\3\5](#правило-035)
    - [Множественное наследование](#множественное-наследование)
  - [Исключения](#исключения)
    - [Access violation](#access-violation)
  - [Типизация](#типизация)
    - [const](#const)
    - [volatile](#volatile)
    - [auto\decltype](#autodecltype)
    - [type-casting](#type-casting)
  - [Шаблоны](#шаблоны)
    - [Вариативные шаблоны](#вариативные-шаблоны)
    - [Специализации шаблонов](#специализации-шаблонов)
      - [Частичная специализация](#частичная-специализация)
      - [Полная специализация](#полная-специализация)
    - [SFINAE](#sfinae)
    - [type-traits](#type-traits)
  - [Особенности языка](#особенности-языка)
    - [ADL](#adl)
    - [Global init fiasco](#global-init-fiasco)
  - [Стандартная библиотека](#стандартная-библиотека)
    - [Потоки ввода вывода](#потоки-ввода-вывода)
    - [Дата и время](#дата-и-время)
    - [Контейнеры](#контейнеры)
    - [Итераторы](#итераторы)
    - [Алгоритмы](#алгоритмы)
    - [Многопоточность](#многопоточность)
  - [Неопределенное и неуточненное поведение](#неопределенное-и-неуточненное-поведение)
  - [С++20](#с20)
  - [Идеомы](#идеомы)
    - [RAII](#raii)
    - [pImpl](#pimpl)
    - [Non-copyable/non-movable](#non-copyablenon-movable)
    - [Erase-remove](#erase-remove)
    - [Copy and swap](#copy-and-swap)
    - [Copy on write](#copy-on-write)
    - [CRTP](#crtp)
  - [Принципы разработки](#принципы-разработки)
    - [SOLID](#solid)
    - [KISS](#kiss)
    - [DRY](#dry)
    - [YANGI](#yangi)
    - [BDUF](#bduf)
    - [Композиция предпочтительней наследования](#композиция-предпочтительней-наследования)
    - [Бритва Окама](#бритва-окама)
    - [Разделяй и властвуй](#разделяй-и-властвуй)
  - [Паттерны проектирования](#паттерны-проектирования)
  - [Жизненный цикл ПО](#жизненный-цикл-по)
  - [Инструменты](#инструменты)
    - [Сборка - CMake](#сборка---cmake)
    - [Разработка - VSCode](#разработка---vscode)
    - [Отладка - gdb](#отладка---gdb)
    - [Версирование - git](#версирование---git)
    - [Линтер](#линтер)
    - [Анализаторы](#анализаторы)
      - [Статические](#статические)
      - [Динамические](#динамические)
  - [Библоитеки](#библоитеки)
    - [boost](#boost)
    - [google test\mock](#google-testmock)
  - [Архитектура](#архитектура)
  - [Операционные системы](#операционные-системы)
  - [(Старое) Особенности языка](#старое-особенности-языка)
  - [const](#const-1)
    - [Переменные](#переменные)
    - [Функции](#функции-1)
  - [Базовые](#базовые)
  - [Последовательность](#последовательность)
  - [Запрещенные](#запрещенные)
  - [Исключения в деструкторе](#исключения-в-деструкторе)
  - [Виртуальные функции в конструкторе или деструкторе](#виртуальные-функции-в-конструкторе-или-деструкторе)
  - [Виртуальный "конструктор"](#виртуальный-конструктор)
- [Возможные ошибки](#возможные-ошибки)
  - [Оператор присвоения](#оператор-присвоения)
  - [Static intialization fiasco](#static-intialization-fiasco)
- [Преобразования типов](#преобразования-типов)
  - [Неявное\неявное преобразование типов](#неявноенеявное-преобразование-типов)
  - [cast](#cast)
- [Идеомы \ техники](#идеомы--техники)
  - [Статический полиморфизм](#статический-полиморфизм-1)
  - [Множественное наследование](#множественное-наследование-1)
  - [Argument Dependent Lookup (ADL)](#argument-dependent-lookup-adl)
- [Многопоточность](#многопоточность-1)


# С++

## Операции

Операции приведены в порядке их приоритетности, каждая группа это отдельный уровень приоритета. Операции одного уровня имеют равных приоритет, который можно изменить при помощи скобок.

```cpp
// :: Разрешения области видимости

// . и -> выбор члена класса
// [] индексация массива
// () вызов функции
// ++, -- постфиксные инкримент\декримент
// typeid механизм RTTI
// const_cast, dynamic_cast, reinterpret_cast, static_cast

// sizeof
// ++, -- префиксные инкримент\декримент
// ~ или compl число необходимое чтобы дополнить все разряды до 1
// ! или not логическое отрицание
// +, - унарные плюс и минус
// & операция взятия адреса
// * разименовывание указателя
// new, delete
// C-style cast ()

// .* и ->* разименовывание указателя члена класса

// *, /, % умножение, деление и остаток от деления

// +, - сложение и вычитание

// <<, >> побитовый сдвиг влево и вправо (*2, /2)

// <, >, <=, >= операции сравнения логических выражений

// ==, != или not_eq операции сравнения логических выражений

// & или bitand побитовое И

// ^ или xor побитовое исключающее И (1 если 0 и 1)

// | или bitor побитовое ИЛИ

// && или and логическое И

// || или or логическо ИЛИ

// ?: тернарный оператор
// = присвоение
// *=, /=, %=, +=, -=, <<=, >>=, &= или and_eq, |= или or_eq ^= or xor_eq
//throw

//, оператор запятая - вычисляет два значения и возвращает второе
с = (a, b); //c == b 
с = a, b;   //с == a, вычисляется как (c = a), b
```
***

## Функции

### Операторы

Большинство операторов могут быть переопределены. Список не переопределяемых:

```cpp
// . выбор члена класса
// .* выбор указателя на член класса
// :: разрешение области
// ?: тернарный оператор
// # препроцессор: преобразование в строку
// ## препроцессор: конкатенация
```

Операторы могут быть определены как член класса, или глобальная функция. Во втором случае функция принимает первым аргументом константную ссылку на объект.
Рекомендации:

```cpp
// Все унарные операторы - Член класса
// = () [] -> ->* - Обязательно член класса
// += -= /= *= ^= &= |= %= >>= <<= - Член класса
// Остальные бинарные операторы - Не член класса
```

Если оператор не является членом классом, он должен быть помечен как friend, для того чтобы работать с private\protected содержимым классов.

Примеры переопределений:

```cpp
class A 
{
    int a;

public:

    A(int a) : a(a) {}

    // Как глобальная функция
    friend const A operator+(const A& lhs, const A& rhs);

    // Как функция класса
    A operator-(A& other) {
        return A(a - other.a);
    }
};

const A operator+(const A& lhs, const A& rhs) {
    return A(lhs.a + rhs.b);
}
```

Перегрузка префиксных и постфиксных инкрементов и декриментов отличается тем, что постификсная форма принимает вторым аргументом int, который не используется


### Lambda

Общий вид:
```cpp
auto lambda = [capture-list](arguments) mutable
{
    ...
}; //Создание

//Если не указывать mutable - по дефолту аргументы не изменяемы

lambda(arguments); //Вызов
```

Списки захвата:
```cpp
[] // ничего не захватывается
[=] // локальные переменные по значению
[&] // локальные переменные по ссылке
[this] // this по ссылке
[*this] // объект по копии, нужен mutable для вызова не const f()
[a, &b] // захват отдельных перменных, по значению и ссылке
[&r = x] // захват переименованной ссылки
[x = x + 1] // инициализация переменной, может быть std::move()
```

Как возвращаемое значение, так и аргументы могут быть типа auto.

Если необходимо хранить переменную или контейнер lambd:

```cpp
std::function<return_type(arguments_types)> lamda;

std::vector<std::function<int(int)>> lambas_vector;
```

Cуществует возможность использовать обобщенные лямбды с переменным числом аргументов:

```cpp
auto variadic_lambda = [](auto... args) { function(args...); }
// Perfect forwarding:
auto variadic_lambda_ = [](auto&&... args) { std::forward<decltype(args)>(args)...; }
```

Так же они могут быть помечены как constexpr, если возможно вычисления будут выполненны на этапе компиляции.

### Функторы

Функтор это объект, у которого перегружен оператор ().
Они активно используются в STL, наравне с lambda, и например могут быть переданы в качестве аргумента в функцию сортировки.

Могут быть помечены как constexpr.

Так же существуют функторы из стандартной библиотеки:

```cpp
// Арифметические
std::plus<int>{};
std::minus<int>{};
std::multiplies<int>{};
std::divides<int>{};
std::modulus<int>{};
std::negate<int>{};

// Логические
std::less<int>{}(1, 0);
std::greater<int>{}(1, 0);
std::equal_to<type>{};
std::not_equal_to<type>{};
std::greater_equal<type>{};
std::less_equal<type>{};

std::logical_and<type>{};
std::logical_or<type>{};
std::logical_not<type>{};

// Побитовые
std::bit_and<type>{};
std::bit_or<type>{};
std::bit_xor<type>{};
std::bit_not<type>{};

// Хэширование
std::hash<Arithmetic>{};
std::hash<Enum>{};
std::hash<std::nullptr_t>{};
std::hash<T*>{};

// Searchers
std::default_searcher<ForwardIt, BinaryPredicate>{};
std::boyer_moore_searcher<ForwardIt, BinaryPredicate>{};
std::boyer_moore_horspool_searcher<ForwardIt, BinaryPredicate>{};

// Отрицание функции (функция как аргумент)
std::not_fn<F>{};
```

### Пользовательские литералы

Стандартные строковые литералы:

```cpp
"Text" //char 
L"Text" //wchar_t

u8"Text" //char - utf8
u"Text" //char16_t
U"Text"//char32_t

//Сырые строки обрамляются в () в "" и могут иметь произвольный delemiter
R"delimiter( raw string )delimeter" 
LR"delimiter( raw string )delimeter"

u8R"delimiter( raw string )delimeter"
uR"delimiter( raw string )delimeter"
UR"delimiter( raw string )delimeter"
```

Помимо стандартных литеральных типов, можно определять пользовательские.

Пример пользовательского литерала преобразования радиан в градусы.

```cpp
long double operator""_degrees(long double value)
{
	return value * M_PI / 180.0;
}

double degrees = 0.38__degrees
```

Список возможных аргументов, при определении пользовательского литерала:

```cpp
( const char * )
( unsigned long long int )	
( long double )	
( char )
( wchar_t )	
( char16_t )	
( char32_t )
( const char * , std::size_t )	
( const wchar_t * , std::size_t )	
( const char16_t * , std::size_t )	
( const char32_t * , std::size_t )
```


***

## Типы данных

### Статическая типизация

### Динамическая типезация

#### RTTI

***

## Указатели и ссылки

### Модель памяти и время жизни

### Ссылки

### Сырые указатели

### Умные указатели

***

## Структуры и классы: ООП

### Конструкторы и деструткоры

### Статический полиморфизм

#### Перегрузка методов

### Динамический полиморфизм

#### Виртуальные методы

#### Таблица виртуальных методов

### Правило 0\3\5

### Множественное наследование

***

## Исключения

### Access violation

***

## Типизация

### const

### volatile

### auto\decltype

### type-casting

***

## Шаблоны

### Вариативные шаблоны

### Специализации шаблонов

#### Частичная специализация

#### Полная специализация

### SFINAE

Очень коротко!

### type-traits

Очень коротко с ссылками!

***

## Особенности языка

### ADL

### Global init fiasco

+???

***

## Стандартная библиотека

### Потоки ввода вывода

### Дата и время

### Контейнеры

### Итераторы

### Алгоритмы

### Многопоточность

***

## Неопределенное и неуточненное поведение

https://en.cppreference.com/w/cpp/language/eval_order

***

## С++20

***

## Идеомы

### RAII

### pImpl

### Non-copyable/non-movable

### Erase-remove

### Copy and swap

### Copy on write

### CRTP

+???

## Принципы разработки

### SOLID

### KISS

### DRY

### YANGI

### BDUF

### Композиция предпочтительней наследования

### Бритва Окама

### Разделяй и властвуй

## Паттерны проектирования

***

## Жизненный цикл ПО

***

## Инструменты

### Сборка - CMake

### Разработка - VSCode

### Отладка - gdb

### Версирование - git

### Линтер

### Анализаторы

#### Статические

#### Динамические

***

## Библоитеки

### boost

### google test\mock

***

## Архитектура

***

## Операционные системы

***
***

## (Старое) Особенности языка

## const

### Переменные

```cpp
//Константный int
const int i = 1; 

//Альтернативная запись
int const j = 2; 

//Указатель на константный int
const int* pI = &i; 

//Константный указатель
int const* const cP = &i; 

//Снятие модификатора
const_cast<int&>(i) = 3; 

int k = 0;
// Ошибка компиляции, так можно добавить константность
static_cast<const int&>(k) = 1; 
```

### Функции

```cpp
class A
{
    std::string value = "test";
    int i = 0;
    
    mutable int j = 0;

    int* p_i; //Предположим что оно проиницилизированно

public:

    void f(const int i) {}

    //Ошибка компиляции, сигнатура считается одинаковой
    void f(int) {} 

    //Так функции могут быть перегружены
    void f_ref(int& r_i) {} 

    //Данная функция будет вызванна от r-value или const int как аргумента
    void f_ref(const int& c_r_i) {}

    //Возврат константной ссылки
    const string& get_const_ref() { return value; } 

    //const функция не даст изменить состояние объекта
    //Из неё могут вызываться только другие const функции
    int const_f() const { return i; } 
    
    //const функции можно перегружать, и они будут выбираться в зависимости от нашего объекта типа A
    int const_f() { return i };

    //Модификация j разрешена из-за ключевого слова mutable
    void set_const_f() const { j = 1; } 
    

    //Такой вызов разрешён, т.к. сам указатель не меняется
    void update_value() const { *p_i = 0; }

    //Другой метод обойти константность, помимо mutable
    void trick() const 
    {
        const_cast<A*>(this)->i = 1;
    }
}
```

#Конструкторы и деструкторы

## Базовые

```cpp
class A
{
    std::string str;
    std::vector vec;

public:

    //Конструктор по умолчанию, конструирует str\vec по умолчанию
    A() {} 

    //Разрушает str\vec
    ~A() {}

    //Конструктор копирования - может быть сгенерирован, если объект может копироваться
    //Например наличие ссылки в членах класса не даст ему сгенерироваться автоматически
    A(const A& other) {}

    //Конструктор перемещения
    A(A&& other) {}


    //Если требуется только стандартное поведение:
    A() = default;

    //Инициализация в констркторе будет происходить в последовательности членов в классе, т.е. str\vec
    A() : vec({0}), str("hi") {}

};
```

## Последовательность

Конструкторы и деструкторы в одном объекте. Конструирование и разрушение из одного скопа. (Принцип один)

## Запрещенные

Закрытые конструкторы\деструкторы:

```cpp
class A
{
    //Старый метод запретить
private: 
    ~A() {}
    A() {}

public:
    //Современный метод
    ~A() = deleted;
    A() = deleted;
};
```

Так можно запретить конструктор копирования или перемещения.
Конструктор можно запретить, например, в синглетоне.

Если конструктор запрещён, то объект можно создавать в статических функциях или классах\функциях friend.

Если деструктор удален есть способ удалить объект:

```cpp
class A
{

public:

    ~A() = deleted;

    void destroy() { delete this; }
};

Однако такой объект может существовать только в динамической памяти, создать его на стеке не удастся, т.к. он не способен потом разрушится.


## Виртуальный деструктор

```cpp
class A
{
public:

    virtual ~A() {}

    virtual f() { std::cout << "A::f" << endl; }

};

class B : public A
{
public:
    ~B() {}

    virtual f() { std::cout << "B::f" << endl; }
};


A* a = new B();
//Если не сделать деструктор виртуальным будет вызван только ~A
delete a; 

//Есть возможность достичь результата без виртуального деструктора - если создать объект shared_ptr<B> и вернуть его как shared_ptr<A> он будет разрушен в деструкторе shared_ptr, но с unique_ptr не выйдет
```

Все классы в STL без виртуального деструктора, потому надо быть осторожным с ними, если возникнет потребность их наследовать.

## Исключения в деструкторе

Исключение выброшенное из деструктора наружу может скрашить приложение (terminate).
Причём один блок try может обработать только 1 исключение, т.е. если обернуть в try создание двух объектов, и оба выкинут исключения - программа завершится аварийно.

Одно из решений, это обрабатывать исключения внутри деструктора.

Так же может быть хорошей идеей вынести код, который может сгенерировать исключение - в отдельную функцию, и вызвать её явно, в блоке try.

```cpp

```

## Виртуальные функции в конструкторе или деструкторе

```cpp

class A
{
public:

    A() { f(); }
    ~A() { f(); }

    virtual f() { std::cout << "A" << endl; }
};

class B : public A
{
public: 

    B() {}

    virtual f() { std::cout << "B" << endl; }
};


//Эта строчка выведет A
B b;

//Эта строчка выведет B
b.f();

//При разрушении B будет выведено тоже A
```

Нужно избегать вызова виртуальных функций, в конструкторе или деструкторе.

## Виртуальный "конструктор"

Рассмотрим проблемную ситуацию

```cpp
class A {

public:
    virtual A* clone() { return (new A(*this)); } 

};

class B : public A {

public:

    //co-variant return type: перегрузка функции возвращающей разные указатели
    virtual B* clone() { return (new B(*this)); }

};

void foo(A* to_copy)
{
    //Хоть мы передаём объект B, сконструирован по копии будет А
    A* a = new A(*to_copy);

    Решение
    A* a2 = to_copy->clone();
}

B b;
foo(&b);
```


# Возможные ошибки

## Оператор присвоения

Для оператора присвоения надо проверять, что объект не присваивается самому себе.

## Static intialization fiasco

Проблема возникает при инциализации одной глобальной переменной другой. Этого надо строго избегаить.

# Преобразования типов
 
## Неявное\неявное преобразование типов

```cpp
class A {};

class A2 {};

class B
{
    std::string str = "test";

public:

    B(const A& a) {}

    explicit B(const A2& a) {}

    std::string operator() const { return str; }
};

A a;
B b = a; //Неявное преобразование

A2 a2;
B b2 = a2; //Запрещено

std::string implicit = b; //Неявное преобразование
```
Опасной может быть ситуация, когда не explicit конструктор имеет 2 аргумента, со дефолтными значениями, и объект такого типа создается присвоением одной переменной соответствующего типа. Будет неявное преобразование типа, с поведением, которое не задуманно.


## cast

:)

# Идеомы \ техники

## Статический полиморфизм

CRTP

## Множественное наследование

Ромбовидное

## Argument Dependent Lookup (ADL)

namespace lookup


# Многопоточность


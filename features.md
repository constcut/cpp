- [С++](#с)
  - [Операции](#операции)
  - [Функции](#функции)
    - [Операторы](#операторы)
    - [Lambda](#lambda)
    - [Функторы](#функторы)
    - [Пользовательские литералы](#пользовательские-литералы)
  - [Типы данных](#типы-данных)
    - [Преобразования типов](#преобразования-типов)
    - [Динамическая типизация](#динамическая-типизация)
      - [RTTI](#rtti)
  - [Указатели и ссылки](#указатели-и-ссылки)
    - [Модель памяти и время жизни](#модель-памяти-и-время-жизни)
    - [Сырые указатели](#сырые-указатели)
    - [Умные указатели](#умные-указатели)
  - [Структуры и классы: ООП](#структуры-и-классы-ооп)
    - [Конструкторы и деструткоры](#конструкторы-и-деструткоры)
    - [Статический полиморфизм](#статический-полиморфизм)
      - [Перегрузка методов](#перегрузка-методов)
    - [Динамический полиморфизм](#динамический-полиморфизм)
      - [Виртуальные методы](#виртуальные-методы)
      - [Таблица виртуальных методов](#таблица-виртуальных-методов)
      - [Вызов виртуальных методов из конструктора и деструктора](#вызов-виртуальных-методов-из-конструктора-и-деструктора)
      - [Вызов чисто виртуальной функции](#вызов-чисто-виртуальной-функции)
    - [Правило 0\5](#правило-05)
    - [Множественное наследование](#множественное-наследование)
  - [Исключения](#исключения)
    - [Исключения в конструкторе](#исключения-в-конструкторе)
    - [Исключения в деструкторе](#исключения-в-деструкторе)
    - [Стандартные типы исключений](#стандартные-типы-исключений)
    - [Гарантии исключений](#гарантии-исключений)
  - [Access violation](#access-violation)
  - [Типизация](#типизация)
    - [Неявное\явное преобразование типов](#неявноеявное-преобразование-типов)
    - [const](#const)
      - [Переменные](#переменные)
      - [Функции](#функции-1)
    - [volatile](#volatile)
    - [Вывод типов](#вывод-типов)
      - [Шаблонных аргументов \ auto \ lamda](#шаблонных-аргументов--auto--lamda)
      - [decltype(auto)](#decltypeauto)
    - [type-casting](#type-casting)
      - [**const_cast**](#const_cast)
      - [**reinterpret_cast**](#reinterpret_cast)
      - [**static_cast**](#static_cast)
      - [**dynamic_cast**](#dynamic_cast)
      - [**std::chrono::duration_cast**](#stdchronoduration_cast)
  - [Шаблоны](#шаблоны)
    - [Не типовые шаблонные параметры](#не-типовые-шаблонные-параметры)
    - [**Типовые шаблонные параметры**](#типовые-шаблонные-параметры)
    - [**Ключевое слово typename**](#ключевое-слово-typename)
    - [Вариативные шаблоны](#вариативные-шаблоны)
    - [Специализации шаблонов](#специализации-шаблонов)
      - [Частичная специализация](#частичная-специализация)
      - [Полная специализация](#полная-специализация)
    - [SFINAE](#sfinae)
    - [type-traits](#type-traits)
  - [Особенности языка](#особенности-языка)
    - [ADL (Argument Dependent Lookup)](#adl-argument-dependent-lookup)
    - [Static intialization fiasco](#static-intialization-fiasco)
  - [Стандартная библиотека](#стандартная-библиотека)
    - [Потоки ввода вывода](#потоки-ввода-вывода)
    - [Дата и время](#дата-и-время)
    - [Контейнеры](#контейнеры)
    - [Итераторы](#итераторы)
    - [Алгоритмы](#алгоритмы)
    - [Многопоточность](#многопоточность)
  - [Неопределенное и неуточненное поведение](#неопределенное-и-неуточненное-поведение)
  - [С++20](#с20)
  - [Идеомы](#идеомы)
    - [RAII](#raii)
    - [pImpl](#pimpl)
    - [Non-copyable/non-movable](#non-copyablenon-movable)
    - [Erase-remove](#erase-remove)
    - [Copy and swap](#copy-and-swap)
    - [Copy on write](#copy-on-write)
    - [CRTP (Curiously recurring template pattern)](#crtp-curiously-recurring-template-pattern)
  - [**IILE**](#iile)
  - [Принципы разработки](#принципы-разработки)
    - [SOLID](#solid)
    - [KISS](#kiss)
    - [DRY](#dry)
    - [YANGI](#yangi)
    - [BDUF](#bduf)
    - [APO](#apo)
    - [Бритва Окама](#бритва-окама)
    - [Разделяй и властвуй](#разделяй-и-властвуй)
  - [Паттерны проектирования](#паттерны-проектирования)
  - [Жизненный цикл ПО](#жизненный-цикл-по)
  - [Библоитеки](#библоитеки)
    - [boost](#boost)
    - [google test\mock](#google-testmock)
  - [Инструменты](#инструменты)
    - [Сборка - CMake](#сборка---cmake)
    - [Разработка - VSCode](#разработка---vscode)
    - [Отладка - gdb](#отладка---gdb)
    - [Версирование - git](#версирование---git)
    - [Линтер](#линтер)
    - [Анализаторы](#анализаторы)
      - [Статические](#статические)
      - [Динамические](#динамические)
  - [Архитектура](#архитектура)
  - [Операционные системы](#операционные-системы)
  - [(Старое) Примеры](#старое-примеры)
  - [Виртуальные функции в конструкторе или деструкторе](#виртуальные-функции-в-конструкторе-или-деструкторе)
  - [Виртуальный "конструктор"](#виртуальный-конструктор)


# С++

## Операции

Операции приведены в порядке их приоритетности, каждая группа это отдельный уровень приоритета. Операции одного уровня имеют равных приоритет, который можно изменить при помощи скобок.

```cpp
// :: Разрешения области видимости

// . и -> выбор члена класса
// [] индексация массива
// () вызов функции
// ++, -- постфиксные инкримент\декримент
// typeid механизм RTTI
// const_cast, dynamic_cast, reinterpret_cast, static_cast

// sizeof
// ++, -- префиксные инкримент\декримент
// ~ или compl число необходимое чтобы дополнить все разряды до 1
// ! или not логическое отрицание
// +, - унарные плюс и минус
// & операция взятия адреса
// * разименовывание указателя
// new, delete
// C-style cast ()

// .* и ->* разименовывание указателя члена класса

// *, /, % умножение, деление и остаток от деления

// +, - сложение и вычитание

// <<, >> побитовый сдвиг влево и вправо (*2, /2)

// <, >, <=, >= операции сравнения логических выражений

// ==, != или not_eq операции сравнения логических выражений

// & или bitand побитовое И

// ^ или xor побитовое исключающее И (1 если 0 и 1)

// | или bitor побитовое ИЛИ

// && или and логическое И

// || или or логическо ИЛИ

// ?: тернарный оператор
// = присвоение
// *=, /=, %=, +=, -=, <<=, >>=, &= или and_eq, |= или or_eq ^= or xor_eq
//throw

//, оператор запятая - вычисляет два значения и возвращает второе
с = (a, b); //c == b 
с = a, b;   //с == a, вычисляется как (c = a), b
```
***

## Функции

### Операторы

Большинство операторов могут быть переопределены. Список не переопределяемых:

```cpp
// . выбор члена класса
// .* выбор указателя на член класса
// :: разрешение области
// ?: тернарный оператор
// # препроцессор: преобразование в строку
// ## препроцессор: конкатенация
```

Операторы могут быть определены как член класса, или глобальная функция. Во втором случае функция принимает первым аргументом константную ссылку на объект.
Рекомендации:

```cpp
// Все унарные операторы - Член класса
// = () [] -> ->* - Обязательно член класса
// += -= /= *= ^= &= |= %= >>= <<= - Член класса
// Остальные бинарные операторы - Не член класса
```

Если оператор не является членом классом, он должен быть помечен как friend, для того чтобы работать с private\protected содержимым классов.

Примеры переопределений:

```cpp
class A 
{
    int a;

public:

    A(int a) : a(a) {}

    // Как глобальная функция
    friend const A operator+(const A& lhs, const A& rhs);

    // Как функция класса
    A operator-(A& other) {
        return A(a - other.a);
    }
};

const A operator+(const A& lhs, const A& rhs) {
    return A(lhs.a + rhs.b);
}
```

Перегрузка префиксных и постфиксных инкрементов и декриментов отличается тем, что постификсная форма принимает вторым аргументом int, который не используется


### Lambda

Общий вид:
```cpp
auto lambda = [capture-list](arguments) mutable
{
    ...
}; //Создание

//Если не указывать mutable - по дефолту аргументы не изменяемы

lambda(arguments); //Вызов
```

Списки захвата:
```cpp
[] // ничего не захватывается
[=] // локальные переменные по значению
[&] // локальные переменные по ссылке
[this] // this по ссылке
[*this] // объект по копии, нужен mutable для вызова не const f()
[a, &b] // захват отдельных перменных, по значению и ссылке
[&r = x] // захват переименованной ссылки
[x = x + 1] // инициализация переменной, может быть std::move()
```

Как возвращаемое значение, так и аргументы могут быть типа auto.

Если необходимо хранить переменную или контейнер lambd:

```cpp
std::function<return_type(arguments_types)> lamda;

std::vector<std::function<int(int)>> lambas_vector;
```

Cуществует возможность использовать обобщенные лямбды с переменным числом аргументов:

```cpp
auto variadic_lambda = [](auto... args) { function(args...); }
// Perfect forwarding:
auto variadic_lambda_ = [](auto&&... args) { std::forward<decltype(args)>(args)...; }
```

Так же они могут быть помечены как constexpr, если возможно вычисления будут выполненны на этапе компиляции.

### Функторы

Функтор это объект, у которого перегружен оператор ().
Они активно используются в STL, наравне с lambda, и например могут быть переданы в качестве аргумента в функцию сортировки.

Могут быть помечены как constexpr.

Так же существуют функторы из стандартной библиотеки:

```cpp
// Арифметические
std::plus<int>{};
std::minus<int>{};
std::multiplies<int>{};
std::divides<int>{};
std::modulus<int>{};
std::negate<int>{};

// Логические
std::less<int>{}(1, 0);
std::greater<int>{}(1, 0);
std::equal_to<type>{};
std::not_equal_to<type>{};
std::greater_equal<type>{};
std::less_equal<type>{};

std::logical_and<type>{};
std::logical_or<type>{};
std::logical_not<type>{};

// Побитовые
std::bit_and<type>{};
std::bit_or<type>{};
std::bit_xor<type>{};
std::bit_not<type>{};

// Хэширование
std::hash<Arithmetic>{};
std::hash<Enum>{};
std::hash<std::nullptr_t>{};
std::hash<T*>{};

// Searchers
std::default_searcher<ForwardIt, BinaryPredicate>{};
std::boyer_moore_searcher<ForwardIt, BinaryPredicate>{};
std::boyer_moore_horspool_searcher<ForwardIt, BinaryPredicate>{};

// Отрицание функции (функция как аргумент)
std::not_fn<F>{};
```

### Пользовательские литералы

Стандартные строковые литералы:

```cpp
"Text" //char 
L"Text" //wchar_t

u8"Text" //char - utf8
u"Text" //char16_t
U"Text"//char32_t

//Сырые строки обрамляются в () в "" и могут иметь произвольный delemiter
R"delimiter( raw string )delimeter" 
LR"delimiter( raw string )delimeter"

u8R"delimiter( raw string )delimeter"
uR"delimiter( raw string )delimeter"
UR"delimiter( raw string )delimeter"
```

Помимо стандартных литеральных типов, можно определять пользовательские.

Пример пользовательского литерала преобразования радиан в градусы.

```cpp
long double operator""_degrees(long double value)
{
	return value * M_PI / 180.0;
}

double degrees = 0.38__degrees
```

Список возможных аргументов, при определении пользовательского литерала:

```cpp
( const char * )
( unsigned long long int )	
( long double )	
( char )
( wchar_t )	
( char16_t )	
( char32_t )
( const char * , std::size_t )	
( const wchar_t * , std::size_t )	
( const char16_t * , std::size_t )	
( const char32_t * , std::size_t )
```


***

## Типы данных

C++ является статически типизированным языком, это значит что тип переменной не может меняться после инициализации.

### Преобразования типов

Безопасные преобразования, без потери данных:

```cpp
bool -> char -> short -> int -> double -> long double
bool -> char -> short -> int -> long -> long long
unsigned char -> unsigned short -> unsigned int -> unsigned long
float -> double -> long double
```

### Динамическая типизация

#### RTTI

Существует ключевое слово typeid, которое может принимать как аргумент тип или выражение.

```cpp
typeid(int).name();
typeid(expression).nam();
```

Помимо получения имени типа есть ещё функции в типе std::type_info, возвращаемым оператором typeid().

Проверка является ли тип надлежащим.

```cpp
typeid(int).before(typeid(char)); // == false
typeid(char).before(typeid(int)); // == true
```

Возможно получить хэш значение из std::type_info

```cpp
size_t hash_id = typeid(int).hash_code();
```

***

## Указатели и ссылки

Указатель ссылается на область в памяти, они могут быть взяты от некоторой перменной, могут быть сравненны, к ним пременимы операции сложения и вычитания, и они могут быть разименованы, для получения значения переменной на которую они указывают.

Ссылки похожи на указатели, но они не содержут операций сравнения и операции сложения и вычитания.

### Модель памяти и время жизни

* Глобальны переменные
* Локальные переменные и агрументы функции, уничтожаемые при выходе из области видимости
* Динамически аллоцированные данные

Так же особые модели памяти используются в многопоточных приложениях, при взаимодействии с std::atomic, о них в разделе многопоточность.

### Сырые указатели

Используются для предоставления доступа к объекту, через указатель на его базовый класс.

Так же при работе с сырыми указателями существует возможность конструирования объекта в уже выделенной памяти (placement new).

```cpp
unsigned char bufer[sizeof(int)] ;

int *pInt = new (bufer) int(42);
```

При использовании placement new не вызывается delete, но требуется вызывать деструктор, если он есть у объекта.

```cpp
unsigned char bufer[sizeof(NewClass)] ;
NewClass *pClass = new (bufer) NewClass(42);
pClass->~NewClass(); //Без этой строчки объект не будет разрушен
```

Так же при выделении массивов при помощи оператора new[] существует возможность задать значения по умолчанию:

```cpp
int* pArr = new int[N]{}; - создаёт массив с дефолтными значениями
```

### Умные указатели

* std::unique_ptr - основной тип умного указателя
* std::shared_ptr - указатель может использоваться в разных частях программы, деалокация происходит при уничтожении последнего объекта класса std::shared_ptr
* std::weak_ptr - используется для решения проблемы перекрестных ссылок, когда объекты ссылаются друг на друга, и не могут использовать shared_ptr, т.к. иначе память не будет высвобождена

std::weak_ptr создаётся из объекта std::shared_ptr, и может проверять является ли указатель висячим.

Умные указатели могут так же использоваться для аллокации массивов:

```cpp
// Для того чтобы освобождать память правильно может понадобится свой deleter
std::shared_ptr<int> array_with_deleter(new int[10], std::default_delete<int[]>());

//Эквивалентно:
std::shared_ptr<int> sp(new int[10], [](int *p) { delete[] p; });

//Однако если не требуется использование общей памяти можно использовать std::unique_ptr
std::unique_ptr<int[]> unique_array(new int[10]);
```

***

## Структуры и классы: ООП

### Конструкторы и деструткоры

Конструкторы вызываются от базового класса, к дочерним.
Деструкторы вызываются в противоположном направлении, от дочерних классов к базовому.

Если конструктор базового класса требует аргументов, тогда он должен быть вызван в конструкторе дочернего класса:

```cpp
class A 
{
public:
    A(int a) {}
};

class B  : public A
{
public:
    B() : A(1) {}
};
```

Существует возможность запретить конструктор, пометив его ключевым словом = delete. Таком можно запретить копирование или перемещени объекта.

### Статический полиморфизм

#### Перегрузка методов

В языке C++ могут быть перегруженны функции. Перегруженные функции имеют одинаковое название, но разное количество аргументов, и\или разных тип аргументов.

Вызываемая функция определяется на этапе компиляции.

### Динамический полиморфизм

#### Виртуальные методы

Виртуальные функции реализуют механизм позднего связавания, или дианамический полиморфизм. Он отличает от статического тем, что происходит на этапе выполнения.

Для этого требуется пометить функцию в базовом классе ключевым словом virtual. И определить такую же функцию в дочернем классе. При переопределении функции в дочернем классе крайне желательно использовать ключевое слово override, оно позволяет проще читать код, а так же может защитить от ошибки когда сигнатуры функций различались.

Суть полиморфизма реализуемого через виртуальные функции сводится к идее использования указателя\ссылки интерфейса (базового класса) для разных реализацией дочернего. 


#### Таблица виртуальных методов

Указатель на таблицу виртуальных методов vptr присутствует в любом классе, которых содержит хотя бы 1 виртуальную функцию.

Если в базовом классе есть хотя бы 1 виртуальная функция, деструктор в ней должен быть помечен virtual. В противном случае при удалении указателя на базовый класс, по адресу которого находится дочерний класс - будет вызван только деструктор базового класса.

При наличии аргументов по умолчанию, будут выбираться те, что соответствуют типу указателя, по которому вызывается функция объекта. Т.е. это происходит на этапе компиляции, и для родительского указателя будет взят родительский аргумент по умолчанию, а для дочернего - дочерний элемент по умолчанию.


#### Вызов виртуальных методов из конструктора и деструктора

Когда виртуальная функция вызывается из конструктора, т.к. конструкторы дочерних классов ещё не вызывались и потому реализованные в них функции не будут вызванны. Таким образом при вызове виртуальной функции из конструктора будет вызванна та его версия, которая заполненна в таблице виртуальных функций к моменту выполнения конструктора.

При вызове виртуальных функций из деструктора возникает схожая проблема. Т.е. если мы вызываем виртуальную функцию из деструктора базового класса, будет вызванна та его версия, которая находится в таблице виртуальных методов. Те деструкторы дочерних классов, которые уже отработали, очистят таблицу виртуальных функций от своих методов.

Однако если поведение описанное выше соответствует задуманному, т.е. ошибка отсутствует можно вызывать функции используя явное указание на класс из которого вызывается функция. Это никак не меняет поведение программы, но читать такой код проще, и компилятор\статический анализатор не выдадут предупреждения о возможной ошибке.

```cpp
B() {
  std::cout << "B()\n";
  A::foo();
  B::bar();
};
```

#### Вызов чисто виртуальной функции

Чисто виртуальные функции используются в базовых классов, в которых отсутствует реализация этого виртуального метода. Подобная методология позволяет создавать абстрактные классы, объекты которых нельзя создать. Однако указатели на такие классы позволяют обращаться к дочерним классам и вызывать их виртуальные функции.

Если вызвать такую функцию из конструктора базового класса это приведёт к аварийному завершению программы.


### Правило 0\5

Правило 3 и 5 гласит, что если нам требуется реализация копирующего или перемещающего конструкторов, или соотвествующих операторо, или деструктора работающего с выделяемой памятью - рекомендуется реализовать все эти функции.

Правило 0 гласит, что не следует вручную создавать такие функции, а доверить им поведение по умолчанию = default. А для хранения указателей использовать их умные версии, избавляя себя от необходимости реализовывать деструктор.


### Множественное наследование

Пример множественного наследования:

```cpp
class X
{};
class Y
{};
class Z
{};
class A : public X, public Y, public Z
{};
```

При конструировании объекта вначале выполняются конструкторы базовых классов, в порядке их выполнения. Потом конструкторы членов результирующего класса. И уже само тело конструктора результирующего класса. Деструкторы так же вызываются в противоположной последовательности.

Правила доступа к членам класса такие же как при наследовании от одного класса. Однако возможны проблемы:

* Если в порожденном классе используется член с таким же именем, как в одном из базовых классов
* Если в нескольких базовых классах определены члены с одинаковыми именами

В этих случаях необходимо использовать оператор разрешения видимости для уточнения элемента, к которому осуществляется доступ, именем требуемого класса.

Однако базовый класс может быть задан только однажы во всей иерархии наследования. Для того чтобы включить базовый класс более одного раза используется виртуальное наследование \ ромбовидное наследование:

```cpp
class X
{};
class Y : virtual public X
{};
class Z : virtual public X
{};
class A : public Y, public Z
{};
```

Тогда конструктор X будет вызван единожды. Без ключевого слова virtual конструкторы X будут вызванны дважды, перед конструктором Y, и перед конструктором Z.

Конструкторы и деструкторы при использовании виртуальных базовых классов выполняются в следующем порядке:

* Конструкторы виртуальных базовых классов выполняются до конструкторов не виртуальных базовых классов, независимо от того, как эти классы заданы в списке порождения
* Если класс имеет несколько виртуальных базовых классов, то конструкторы этих классов вызываются в порядке объявления виртуальных базовых классов в списке порождения
* Деструкторы виртуальных базовых классов выполняются после деструкторов не виртуальных базовых классов.

Если у нескольких наследуемых классов есть одинаковые функции, то для доступа к ним нужно либо использовать явное расширение области видимости, либо же использовать ссылку\указатель на требуемый класс, для вызова соответствующей функции.

***

## Исключения

Исключения прерывают поток выполнения комманд функции. Отличие throw от return, стек будет раскручиваться до тех пор пока не будет найден блок try, и все объекты по пути к этому блоку будут разрушаться.

Если исключение не было обработано - это приводит к аварийному завершению программы.

Так же исключение можн пробросить дальше по стеку, используя ключевое слово throw без параметра.

Блоки catch обрабатываются в порядке их определения, потому если вначале разместить блок с std::exception, а потом с std::logic_error, обработан будет только первый блок, т.к. это базовый класс для std::logic_error.

Так же блок обработки catch может иметь аргумент "...", в этот блок перейдёт управление, если не ни один другой блок не смог обработать исключение.

### Исключения в конструкторе

Если конструктор выбрасывает исключение, то объект не будет сконструкирован. Как следствие не будет вызван деструктор. Иногда это может приводить к утечкам памяти. 

Однако выбрасывать исключения в конструкторах всё же можно. Стандарт гарантирует, что при выбросе исключения из конструктора, все уже сконструкированые члены объекты будут успешно разрушены. Как следствие если мы используем идеому RAII то проблемы не будет.

### Исключения в деструкторе

Начиная с C++11 деструкторы помечены как noexcept, это означает что они не могут выбрасывать исключения наружу, это приводит к аварийному завершению программы.

Однако даже если исключения стремятся быть обработаны, проблемы могут могут возникнуть по другим причинам:

Программа не должна выбрасывать исключения, пока происходит обработка другого исключения, т.к. раскрытка стека до момента нахождения блока try. Это приведёт к аварийному завершению программы.

Причина такого поведения может быть в том, что один из деструкторов при раскрутке стека выбрасывает исключение сам, либо же не обрабатывает исключение функции, которую вызывает.

Другая проблема может возникнуть когда исключение покидает блок try, тогда происходит разрушение всех объектов, которые созданы в блоке try. Если один из объектов выкинет исключение в деструкторе, то программа завершится аварийно.

В стандартный библиотеке существует функция std::uncaught_exception, которая позволяет проверить почему уничтожается объект, из-за выброшенного исключения, или же по другой причине. Однако, желательно не использовать её, по мере возможностей.

### Стандартные типы исключений

Существует множество типов унаследованных от std::exception. В объектах исключений существует фунция what, возвращающая const char *.

```cpp
logic_error
    invalid_argument
    domain_error
    length_error
    out_of_range
    future_error

runtime_error
    range_error
    overflow_error
    underflow_error
    regex_error
    system_error
    ios_base::failure
    filesystem::filesystem_error(C++17)
    tx_exception(TM TS)
    nonexistent_local_time(C++20)
    ambiguous_local_time(C++20)
    format_error(C++20)

bad_typeid
bad_cast
    bad_any_cast(C++17)

bad_optional_access(C++17)
bad_weak_ptr
bad_function_call
bad_alloc
    bad_array_new_length

bad_exception
bad_variant_access(C++17)
```

Так же существует возможность определить функцию, которая будет вызываться вместо terminate, при условии отсутствия обработки выброшенного исключения.

### Гарантии исключений

Существует 4 уровня гарантий исключений для функции:

* noexcept - гарантия что код не выбрасывает исключение никогда
* Строгая гарантия - если функция выходит за пределы области видимости из-за исключения не случится утечки памяти, и состояние программы будет не изменено
* Базовая гарантия - утечки не будет, и объект в рабочем состоянии, но состояние может быть изменено
* Отсутствие гарантий - возможны утечки и объект может стать не рабочим

## Access violation

Аварийное состояние, которое возникает при обращении к памяти, к которой не должно быть доступа. 

Такие исключительные ситуации не могут быть обработанны при помощи стандартных средств языка C++. 

В компиляторах MS Visual C++ существуют отдельные блоки для этой цели.

Другой вариант, это обработка POSIX сигналов, например SEG_FAULT.

***

## Типизация

### Неявное\явное преобразование типов

```cpp
class A {};

class A2 {};

class B
{
    std::string str = "test";

public:

    B(const A& a) {}

    explicit B(const A2& a) {}

    std::string operator() const { return str; }
};

A a;
B b = a; //Неявное преобразование

A2 a2;
B b2 = a2; //Запрещено

std::string implicit = b; //Неявное преобразование
```
Опасной может быть ситуация, когда не explicit конструктор имеет 2 аргумента, со дефолтными значениями, и объект такого типа создается присвоением одной переменной соответствующего типа. Будет неявное преобразование типа, с поведением, которое не задуманно.

### const

#### Переменные

```cpp
//Константный int
const int i = 1; 

//Альтернативная запись
int const j = 2; 

//Указатель на константный int
const int* pI = &i; 

//Константный указатель
int const* const cP = &i; 

//Снятие модификатора
const_cast<int&>(i) = 3; 

int k = 0;
// Ошибка компиляции, так можно добавить константность
static_cast<const int&>(k) = 1; 
```

#### Функции

```cpp
class A
{
    std::string value = "test";
    int i = 0;
    
    mutable int j = 0;

    int* p_i; //Предположим что оно проиницилизированно

public:

    void f(const int i) {}

    //Ошибка компиляции, сигнатура считается одинаковой
    void f(int) {} 

    //Так функции могут быть перегружены
    void f_ref(int& r_i) {} 

    //Данная функция будет вызванна от r-value или const int как аргумента
    void f_ref(const int& c_r_i) {}

    //Возврат константной ссылки
    const string& get_const_ref() { return value; } 

    //const функция не даст изменить состояние объекта
    //Из неё могут вызываться только другие const функции
    int const_f() const { return i; } 
    
    //const функции можно перегружать, и они будут выбираться в зависимости от нашего объекта типа A
    int const_f() { return i };

    //Модификация j разрешена из-за ключевого слова mutable
    void set_const_f() const { j = 1; } 
    

    //Такой вызов разрешён, т.к. сам указатель не меняется
    void update_value() const { *p_i = 0; }

    //Другой метод обойти константность, помимо mutable
    void trick() const 
    {
        const_cast<A*>(this)->i = 1;
    }
}
```

### volatile

Ключевое слово для типа переменной, которое указывает на возможность использования переменной извне, что ведёт к запрету на оптимизацию.

Без ключевого слова volatile компилятор решит что переменная не меняется никогда, и все условия с ней будет оптимизировать на этапе компиляции.

Другой использования volatile: зануления конфеденциальной информации, т.к. компилятор может оптимизировать эту операцию, если область памяти с информацией после не используется после зануления.

### Вывод типов

![image info](images/type_deduction.png)

Правила для вывода шаблонных аргументов:

+ для указателей и ссылок
+ для обычных типов
+ r-value ссылки, которые в шаблонах работают не совсем как r-value, а как forwarding reference и в зависимости от того чем инициализируется становится либо r-value либо l-value ссылкой.

Ключевое слово auto наследует правила вывода всех шаблонных аргументов.

Ключевое слово decltype имеет собственные правила вывода типов.

Списки захвата lambda наследуют правила вывода типов для ссылок и указателей шаблонных аргументов.

Вывод возвращаемых типов lambda, который как auto наследует правила вывода шаблонных аргументов.

#### Шаблонных аргументов \ auto \ lamda

Для (T param) отбрасываются ссылки, const, volatile.

Для (const\volatile T param) так же отбрасываются, но param будет иметь указанный спецификатор.

Для (T& param) отбрасываются ссылки, но сохраняются const\volatile. При этом param будет иметь тип ссылки. Если для param нужно добавить консткнтность, то требуется использовать (const T& param).

Если мы передаём массивы то: T = int[10], param = int(&)[10].
Если мы передаём функцию то: T = voic(), param = void(&)().

Для (T* param) действуют такие правила. Модификаторы сохраняются для T, но отбрасывается указатель для T, но param будет указателем.

Для (T&& param), т.е. forwarding refernce сохраняются спецификаторы для T, а param становится либо l-value, либо r-value ссылкой.

Ключевое слово auto наследует поведение вывода шаблонных аргументов.

Список захвата lamda наследует поведение вывода шаблонных аргументов. Для простых типов, и для ссылок и указателей.

Важно отметить, что если захваченное значение нужно модифицировать, требуется пометить lambda ключевым словом mutable. Но если захват при помощи ссылки - то её можно модифицировать, если только захватывается не константный объект.

#### decltype(auto)

Сохраняет модификаторы.

### type-casting

#### **const_cast**

Используется для снятия квалификаторов const\volatile. Может применяться только к указателям, ссылкам или указателям на член класса.

#### **reinterpret_cast**

Позволяет преобразовывать любой указатель в указатель любого другого типа. Также позволяет преобразовывать любой целочисленный тип в любой тип указателя и наоборот.

#### **static_cast**

Static_cast создан для выполнения всех видов преобразований, разрешённых компилятором. Все преобразования работают, только если есть совместимость по const и volatile.

Необходим для преобразования enum class.

Так же может использоваться для явного указания, какую из перегруженных функций брать:

```cpp
std::transform(s.begin(), s.end(), s.begin(), static_cast<int(*)(int)>(std::toupper));
```

#### **dynamic_cast**

Преобразует ссылку или указатель вниз по иерархии наследования, т.е. из типа предка в тип потомка, с проверкой возможно ли такое преобразование.

#### **std::chrono::duration_cast**

Преобразование между разными длительностями времени (секунда\минута итд). static_cast не подходит, из-за возможной потери точности. 

***

## Шаблоны

### Не типовые шаблонные параметры

Существует 4 вариации:

```cpp
template <size_t> // или <size_t N>
struct int_array { };

template <size_t = 42> // или <size_t N = 42>
struct array { };

// Начиная с C++11:
template <size_t ...> // или <size_t ...ints>
class sizeT_sequence { };

// Начиная с C++17:
template<auto V> // или <decltype(auto) V>
struct B {  };
```

Параметром могут выступать:

+ l-value reference
+ std::nullptr_t
+ integral type (bool, char, signed char, unsigned char, short, ...)
+ pointer
+ pointer to member
+ enumeration

### **Типовые шаблонные параметры**

Три наиболее часто используемых варианта:

```cpp
template <class> // или <typename T>
class FalseVector { ... };

template <class T, class Alloc = std::allocator<T>> 
class TrueVector { ... };

// Начиная с C++11:
template <class ...> // или <typename ...Types>
class tuple { .... };
```

Начиная с C++17 доступны три более экзотических вариантов, шаблон в шаблоне:

```cpp
template <class K, class T, template <class> class Container>
class MyMap
{
	Container<K> keys;
	Container<T> values;
};

template<class T> class my_array { ... };

template<class K, class T, template <class> class Container = my_array>
class MyMap { ... };


template <class K, class T, template <class, class> class ...Map>
class MyMap : Map<K, T>... { ... };
```

### **Ключевое слово typename**
***

Может быть использованно несколькими разными способами:

```cpp
template <typename T>
struct X : B<T> // B<T> is dependent T
{
//Если не написать typename T::A может интерпретироваться не верно
	typename T::A* pa; // T::A зависит T

	void f(B<T>* pb)
	{
		static int i = B<T>::i;
		pb->j++; // pb->j is dependent variable from T ??? B ???
	}
}
```

### Вариативные шаблоны

```cpp
// C++17:

template <class T1, class T2, class ...TN>
bool equalsAnyOf(const T1& t1, const T2& t2, const TN&... tN) noexcept
{
	// Лаконичное решение через свертку функций, в отличии от рекурсии C++17
	return ((t1 == t2) || ... || (t1 == tN));
}

std::cout << equalsAnyOf(0, 'a', 0.0, 42);
```

Существует четыре вида свёрток функций:

```cpp
(pack op ...) = (E_1 op (... op (E_N-1 op E_N)))
(... op pack) = (((E_1 op E_2) op ...) op E_N)
(pack op ... op init) = (E_1 op (... op (E_N-1 op (E_N op I))))
(init op ... op pack) = ((((I op E1) op E2) op ...) op E_N)
```

Операции:
```cpp
+,  -,  *,  /,  %,  ^,  &,  |,  =,  <,  >,  <<,  >>,  
+=,  -=,  *=,  /=,  %=,  ^=, &= |=, 
<<=, >>=, ==, !=, <=, >=, &&, ||, .*, ->*
и оператор ,
```

### Специализации шаблонов

#### Частичная специализация

```cpp
// Шаблонный класс
template <class T, class Deleter>
class untique_ptr
{

public:
	T* operator->() const noexcept;
}

// Частичная специализация для шаблонного класса
// Реалиция unique_ptr для массивов
template <class T, class Deleter>
class unique_ptr<T[], Deleter> 
{

public:
	T& operator[](size_t idx) noexcept;
	const T& operator[](size_t idx) const noexcept;
}
```

Для функций частичная специализация не доступна.

#### Полная специализация

Пример для классов:

```cpp
template <class T>
class vector // class template
{
	...
};

// full specialization for vector<bool>:
template<>
class vector<bool> 
{
	....
};
```

Пример для функций:

```cpp
template <class T>
void print(const T& obj) // function template
{
	std::cout << obj;
};

class SomeClass {...};

// full specialization for print:
template<>
void print<SomeClass>(const SomeClass& obj) 
{
	std::cout << obj;
};
```

### SFINAE

Subsituation Failure Is Not An Error - возможность манипулировать перегрузками какой-то функции, при необходимости скрывая некоторые из них при помощи создания искусственных ошибок. 

При определении перегрузок функции ошибочные инстанциации шаблонов не вызывают ошибку компиляции, а отбрасываются из списка кандидатов на наиболее подходящую перегрузку. 

### type-traits

Позволяют узнать о характеристиках шаблонного аргумента.

Подробнее: https://en.cppreference.com/w/cpp/header/type_traits

***

## Особенности языка

### ADL (Argument Dependent Lookup)

Позволяет находить определения в связанных областях видимости.
Не применяется если обчыный поиск позволяет найти нужное имя.

### Static intialization fiasco

Проблема возникает при инциализации одной глобальной переменной другой. Этого надо строго избегаить.

***

## Стандартная библиотека

### Потоки ввода вывода

### Дата и время

### Контейнеры

### Итераторы

### Алгоритмы

### Многопоточность

***

## Неопределенное и неуточненное поведение

https://en.cppreference.com/w/cpp/language/eval_order

***

## С++20

***

## Идеомы

### RAII

Resource Acquisition Is Initialization: получение некоторого ресурса связанно с созданием объекта, а высвобождение с разрушением.

Т.к. при выходе из области видимости происходит разрушение локальныйх объектов, RAII безопасно использовать с исключениями.

Примеры в стандартной библиотеке: std::unique_ptr, std::ifstream, std::mutex, std::string, std::vector.

### pImpl

Private implementation: используется для того чтобы скрыть детали от других разработчиков, а так же помогают уменьшить нагрузку на компилятор при рекомпиляции скрытой реализации за счёт минимизация зависимостей компиляции и разделения интерфейса и реализации.

```cpp
// my_class.h
class my_class {
   //  ... all public and protected stuff goes here ...
private:
   class impl; 
   std::unique_ptr<impl> pimpl; // opaque type here
};

// my_class.cpp
class my_class::impl {  // defined privately here
  // ... all private data and functions: all of these
  //     can now change without recompiling callers ...
};

my_class::my_class(): pimpl( new impl )
{
  // ... set impl values ...
}
```

### Non-copyable/non-movable

Запрет на копирование\перемещение.

Достигается за счёт удаления конструктора и оператора, копирования и перемещения соответственно.

### Erase-remove

Метод для быстрого прореживания массива данных:

```cpp
std::string remove_from = "Some    spaces    were    here"
remove_from.erase(std::remove_if(remove_from.begin(), remove_from.end(),
                              [](unsigned char x) { return std::isspace(x); }),
```


Устойчивость к исключениям заключается в том, что в операторе присваивания нет точки, где генерация исключения могла бы привести к утечке памяти.

### Copy and swap

Идиома позволяющая реализовывать устойчивые к исключениям операции присвоения.

```cpp
class Copyable 
{
public:

	Copyable& operator=(Copyable value)
	{
		std::swap(value, *this);
		return *this;
	}
};
```

### Copy on write

При чтении данных используется общий объект, а при изменении - создаётся модифицированная копия.

Имеет общее с паттерном "легковес".


### CRTP (Curiously recurring template pattern)

```cpp
template <class T>
struct Base
{
};

struct Derived : Base<Derived>
{
};
```

Проблемная ситуация, для которой нужна такая странная композиция:

```cpp
template <class T = intmax_t>
class Rational
{
  ...
public:
	Rational() = default;

	friend bool operator<(const Rational<T>& l, const Rational<T>& r) noexcept
	{
		return ....;
	}
}
//Однако возникает сложность, если требуется оператор >
```

Пример:

```cpp
template <class T>
struct less_than_comparable
{
	friend bool operator>(const T& l, const T& r) noexcept
	{
		return r < l;
	}
	friend bool operator<=(const T& l, const T& r) noexcept
	{
		return !(r < l);
	}
	friend bool operator>=(const T& l, const T& r) noexcept
	{
		return !(l < r);
	}
	
};

template <class T = uint64_t>
class Rational : less_than_comparable<Rational<T>>
{ //Класс объявленый выше с операцией < 
};

//Обобщенная задача решена!
```

Эта идеома применима при статическом полиморфизме, но это не даёт большого прироста производительности.


## **IILE**

Immediately Invoked Lambda Expression: идеома используется для комплексной инициализации ресурсов.

Её суть заключается в создании lambd'ы, которая немедленно вызывается.

Код ниже создаёт константный вектор, который может быть заполнен произвольным образом.

```cpp
const std::vector<int> some_vector = [](){ return std::vector<int>(10);}();
```

## Принципы разработки

### SOLID

* Single responsibility principle (принцип единственной ответственности)
* Open-closed principle (принцип открытости/закрытости)
* Liskov substitution principle (принцип подстановки Лисков)
* Interface segregation principle (принцип разделения интерфейса)
* Dependency inversion principle (принцип инверсии зависимостей)

Принцип единой ответственности: для каждого класса должно быть определено единственное назначение. Все ресурсы, необходимые для его осуществления, должны быть инкапсулированы в этот класс и подчинены только этой задаче.

Принцип открытости\закрытости: программные сущности должны быть открыты для расширения, но закрыты для модификации.

Принцип подстановки Лисков: функции, которые используют базовый тип, должны иметь возможность использовать подтипы базового типа не зная об этом.

Принцип разделения интерфейса: много интерфейсов, специально предназначенных для клиентов, лучше, чем один интерфейс общего назначения.

Принцип инверсии зависимостей: Зависимость на Абстракциях. Нет зависимости на что-то конкретное.

### KISS

Keep It Simple, Stupid / Будь проще

Не придумывайте к задаче более сложного решения, чем ей требуется.

### DRY

Don’t Repeat Yourself / Не повторяйтесь

Уход от дублирования кода.

### YANGI

You Aren’t Gonna Need It / Вам это не понадобится

Если пишете код, то будьте уверены, что он вам понадобится. Не пишите код, если думаете, что он пригодится позже.

### BDUF

Big Design Up Front / Глобальное проектирование прежде всего

Проектируй код перед тем, как начинать его писать.

### APO

Avoid Premature Optimization / Избегайте преждевременной оптимизации

Эта практика побуждает разработчиков не оптимизировать код до того, как необходимость этой оптимизации будет доказана.

### Бритва Окама

Не создавайте ненужных сущностей без необходимости. Будьте прагматичны — подумайте, нужны ли они, поскольку они могут в конечном итоге усложнить вашу кодовую базу.

### Разделяй и властвуй

Парадигма разработки алгоритмов, заключающаяся в рекурсивном разбиении решаемой задачи на две или более подзадачи того же типа, но меньшего размера, и комбинировании их решений для получения ответа к исходной задаче; разбиения выполняются до тех пор, пока все подзадачи не окажутся элементарными.

## Паттерны проектирования

***

## Жизненный цикл ПО

***

## Библоитеки

### boost

### google test\mock

***

## Инструменты

### Сборка - CMake

### Разработка - VSCode

### Отладка - gdb

### Версирование - git

### Линтер

### Анализаторы

#### Статические

#### Динамические


***

## Архитектура

***

## Операционные системы

***
***

## (Старое) Примеры

## Виртуальные функции в конструкторе или деструкторе

```cpp

class A
{
public:

    A() { f(); }
    ~A() { f(); }

    virtual f() { std::cout << "A" << endl; }
};

class B : public A
{
public: 

    B() {}

    virtual f() { std::cout << "B" << endl; }
};


//Эта строчка выведет A
B b;

//Эта строчка выведет B
b.f();

//При разрушении B будет выведено тоже A
```

Нужно избегать вызова виртуальных функций, в конструкторе или деструкторе.

## Виртуальный "конструктор"

Рассмотрим проблемную ситуацию

```cpp
class A {

public:
    virtual A* clone() { return (new A(*this)); } 

};

class B : public A {

public:

    //co-variant return type: перегрузка функции возвращающей разные указатели
    virtual B* clone() { return (new B(*this)); }

};

void foo(A* to_copy)
{
    //Хоть мы передаём объект B, сконструирован по копии будет А
    A* a = new A(*to_copy);

    Решение
    A* a2 = to_copy->clone();
}

B b;
foo(&b);
```
